source functionlib 2> /dev/null
source ./dp_app 2> /dev/null
source ./dplib  2> /dev/null
export USER_BACKUP_AREA=/git/
export ALTERNATE_BACKUP_DIRS=".bak ../version"
dp_version () 
{ 
    : print the version;
    : the SMART way, dp_version backup_ver;
    : date: 2022-08-22;
    : date: 2022-08-27;
    ${*:-echo} 0.4.a
}
dp_funs () 
{ 
    : list all function and their Dot Prof file;
    : date: 2022-07-30;
    : date: 2022-08-19;
    if_missingargs 1 $* && return
    functions $1 | sed "s=$=	$1="
}
dp_install () 
{ 
    : move the run-time components into place;
    : versions are tracked in SRC, not in BIN, LIB    
    : date: 2022-08-20;
    : ------------------ two main components of an APPs BITMELD --;
    : date: 2022-08-27;
    :;
    runfrom $(dp_root)/src || return
    :
    local bin=$(needir $(dp_root)/bin);
    local lib=$(needir $(dp_root)/lib);
    :;
    : ---------------- install Readable Information in the ROOT --;
    :;
    ln -f ./README.md     $(dp_root);
    ln -f ./Changelog.md  $(dp_root);
    ln -f ./ManualPage.md $(dp_root);    
    ln -f ./Workflow.md   $(dp_root);
    ln -f ./Versioning.md $(dp_root);        
    :;
    : ---------------------------------- manufacture the dp_app	--;
    :;
    dp_utilities | cat - ./dplib | onlyChanged dp_app
    :;
    : ------------------------- install just the APP in the BIN	--;
    :;
    chmod 775 ./dp_app
    ln -f ./dp_app $bin;
    :;
    : ------------------------------- install text files in LIB --;
    ln -f ./dot.prof $lib;
    :;
    : ------------------------------------------- all installed --;
    :;
    indir $(dp_root) find . -type file | egrep -v '\.(bak|git)/'
}
dp_all () 
{ 
    : all the functions in the DP family;
    : date: 2022-08-22;
    ${*:-echo} dp dp_{abstracts,all,diff,example,funs,init,install,profs,root,test,tolibrary,utilities,version}
}
dp () 
{ 
    : do Dot Prof;
    : date: 2022-08-19;
    : date: 2022-08-22;
    [[ -f ./.prof ]] || { 
        cp $(dp_root)/lib/dot.prof .prof
    };
    isfunction backup 2>/dev/null && backup .prof
    set ${1:-.prof}
    case $1 in
    .prof ) source $1;;
    * )     fun_asapp $* && return;;
    esac
}
fun_asapp () 
{ 
    : smart family main function, checks to see if ARG is a sub-function;
    : usage: fun_asapp args ... And return;
    : date: 2022-04-09;
    debug ENTRY $# $*;
    [[ $# -lt 1 ]] && { 
        debug ZERO Args;
        return 1
    };
    local caller=$(myname 2);
    local subfun=$1;
    local famfun=${caller}_$subfun;
    debug famfun: $famfun;
    pause;
    isfunction $famfun && { 
        shift;
        fun_subuse $caller $subfun;
        debug FUNCTION famfun $famfun;
        $famfun $*;
        return
    };
    debug NOT a Function $famfun;
    sfg ${caller}_ 1>&2
    return 2
}
fuse () 
{ 
    : returns function context from client functions;
    : named for Functions which USE ..;
    : todo: ADD RULE to preserve only the report_NAME function NEEDS work!    
    : todo: fix NAME=, ...;
    : ...: replace temporary awk file with shell "<( .. )";
    : ...: add trace and leave TMP files on STDERR;
    : usage: $ fuse pattern file ...;
    : ... $ { collect functions on stdin } PIPE fuse pattern;
    : ... $ fuse pattern DEFAULTS to functions in current shell;
    : date: 2017-03-07;
    : date: 2019-04-24;
    : date: 2021-03-09 the sed l,r Paren discovery needed G, global;
    : date: 2022-02-25;
    report_isfile $HOME/tmp && return 1
    local tmp=$(needir $HOME/tmp)
    local awk=$HOME/tmp/fuse.awk;
    local patr="^-a-zA-Z0-9_";
    local a="/[$patr$]$1[$patr\[\)=]/";
    local b="/[$patr$]$1$/";
    ( cat <<'EOF'
        $2 ~ /^[(][)]$/  { f=$1; next; } 
        $1 ~ /^:$/       { next; }
	$1 ~ /^comment$/ { next; }
	$1 ~ /^report_/  { print $1; next; }	
EOF

    printf '
    f != ""  && ( %s || %s )     { printf "%%s\\t%%s\\n", f, $0 }\n
    ' "$a" "$b" ) | tee $tmp/awk.tmp > $awk;
    :;
    : SED separates (...) into ( ... )
    spaceit ${*:2} | sed 's/\([<$]\)(\([^)]*\))/\1( \2 )/g' | tee $tmp/fuse.tmp | awk -f $awk
    llrt $tmp/{awk,fuse}.tmp 1>&2
}
compare_all_lib () 
{ 
    : compare set vs lib function lists;
    : anticipates the general case;
    : date: 2022-08-22;
    if_missingargs 1 $* && return
    local all=${$1}_all
    local lib=./${1}lib
    report_notfunction $all && return 1;
    report_notfile $lib     && return 2;    
    : 
    $all | tpl > .all;
    functions $ib | sort > .lib;
    printf "%s\t%s\t%s\n" .all .lib BOTH
}
false &&
{
	return;
	# see Workflow.md
    mv .ver/* ../version
    backup_ver 0.4.b
    find ../version -type f
    echo . . . . . . .
    ls -al .. ../{bin,lib}
    # ---------------- inspect the versioning functions	--
    #
    def dp_version backup_ver
    # ------------------------------ here is an example	--
    #
    dp_version backup_ver 2>&1

    find $(dp_version backup_ver 2>&1)
    # ----------------------------- show off the latest	--
    #
    ls -lrtd $(find $(dp_version backup_ver 2>&1))

    sed -n '/false/,$p' .prof    
}        
# 
# 
#     # compare_all_lib
#     # backup_ver $(dp_version)
#     # dp_install
    # ls -al .. ../{bin,lib}
    # unset $(functions ../bin/dp{,util}lib})
    # source dp_app
    # git ls-files, git status
    # functions $(which dp_app)
    # test FUN_ASAPP
    # def dp;
    # dp abstracts | j
    # dp help
    # dp_install
    echo . . . . . . .
    dp_utilities | awk '$2 ~ /[(][)]/ { fun = $1; } /reading/ { printf "%s\t%s\n", fun, $0 }'
    

