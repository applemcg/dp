source functionlib 2> /dev/null
source ./dp_app    2> /dev/null
source ./dplib     2> /dev/null
source ./.fuse     2> /dev/null
export USER_BACKUP_AREA=/git/
export ALTERNATE_BACKUP_DIRS=".bak ../version"
alias dpd='off; source ./.prof'
dp_version () 
{ 
    : print the version;
    : the SMART way, dp_version backup_ver;
    : date: 2022-08-22;
    : date: 2022-08-27;
    ${*:-echo} 0.4.a
}
dp_funs () 
{ 
    : list all function and their Dot Prof file;
    : date: 2022-07-30;
    : date: 2022-08-19;
    if_missingargs 1 $* && return;
    functions $1 | sed "s=$=	$1="
}
dp_install () 
{ 
    : move the run-time components into place;
    : versions are tracked in SRC, not in BIN, LIB;
    : date: 2022-08-20;
    : ------------------ two main components of an APPs BITMELD --;
    : date: 2022-08-27;
    :;
    runfrom $(dp_root)/src || return;
    :;
    local bin=$(needir $(dp_root)/bin);
    local lib=$(needir $(dp_root)/lib);
    :;
    : ---------------- install Readable Information in the ROOT --;
    :;
    ln -f ./README.md $(dp_root);
    ln -f ./Changelog.md $(dp_root);
    ln -f ./ManualPage.md $(dp_root);
    ln -f ./Workflow.md $(dp_root);
    ln -f ./Versioning.md $(dp_root);
    :;
    : ---------------------------------- manufacture the dp_app --;
    :;
    dp_utilities | cat - ./dplib | onlyChanged dp_app;
    :;
    : ------------------------- install just the APP in the BIN --;
    :;
    chmod 775 ./dp_app;
    ln -f ./dp_app $bin;
    :;
    : ------------------------------- install text files in LIB --;
    ln -f ./dot.prof $lib;
    :;
    : ------------------------------------------- all installed --;
    :;
    indir $(dp_root) find . -type file | egrep -v '\.(bak|git)/'
}
dp_all () 
{ 
    : all the functions in the DP family;
    : date: 2022-08-22;
    ${*:-echo} dp dp_{abstracts,all,diff,example,funs,init,install} dp_{profs,root,test,tolibrary,utilities,version} dp_{cblock,compareall,functions,header,libraries} dp_{restore,rmfunctions}
}
dp () 
{ 
    : do Dot Prof;
    : date: 2022-08-19;
    : date: 2022-08-22;
    [[ -f ./.prof ]] || { 
        cp $(dp_root)/lib/dot.prof .prof
    };
    isfunction backup 2> /dev/null && backup ./.prof;
    set ${1:-./.prof};
    debug ENTRY $*;
    case $1 in 
        ./.prof)
            source $1
        ;;
        *)
            fun_asapp $* && return
        ;;
    esac
}
dp_compareall () 
{ 
    : compare set vs family function lists;
    : anticipates the general case;
    : date: 2022-08-22;
    if_missingargs 1 $* && return;
    local all=${1}_all;
    local fam="$1 $(sfg ${1}_)";
    debug all: $all;
    debug fam: $fam;
    report_notfunction $all && return 1;
    :;
    $all | tpl | sort > .all;
    echo $fam | tpl | sort > .fam;
    comm .all .fam;
    printf "%s\t%s\t%s\n" .all .fam BOTH
}
dp_diff () 
{ 
    : diff LIB and ./.prof versions of functions;
    : lessons: ?? foreach was OK but Examine your TEST CASE, steady on DIFF ?;
    : date: 2022-08-22;
    debug ENTRY $# $*;
    if_missingargs 2 $* && return;
    local lib=$(which $1);
    shift;
    debug LIB: $lib;
    for fun in $@;
    do
        debug FUN: $fun;
        fun_peek $fun ./.prof > .dotp;
        fun_peek $fun $lib > .dlib;
        diff .dlib .dotp || { 
            printf "RETURN $?\n< $lib\n$fun\t./.prof\n========\n\n\n"
        };
    done
}
dp_header () 
{ 
    : collect the current Header Block from ./.prof;
    awk -v p=1 '$2 ~ /^[(][)]$/ { exit }; p' ${1:-./.prof}
}
dp_cblock () 
{ 
    : collect the current Comment and Execution Blocks from ./.prof;
    awk -v p=0 '$1 ~ /^false$/ { p = 1 }; p' ${1:-./.prof}
}
dp_functions () 
{ 
    : collect the functions from ./.Prof;
    awk -v p=0 '
        $1 ~ /^false$/  { p = 0 };
	$2 ~ /^[(][)]$/ { p = 1 };
	p
    ' ${1:-./.prof} | functions
}
dp_restore () 
{ 
    : collect the ./.prof functions in these versions:;
    : .prof.now -- the current function block;
    : .prof.nxt -- current less functions removed by rmfunctions;
    : .prof.tmp -- the reconstructed .prof;
    : related: dp_rmfunctions ./.prof.tmp into a .prof.nxt;
    :;
    function _do_restore () 
    { 
        dp_header;
        declare -f $(dp_functions) > ./.prof.now;
        [[ -f ./.prof.nxt ]] && cat ./.prof.nxt || cat ./.prof.now;
        dp_cblock
    };
    _do_restore > ./.prof.tmp;
    chmod +x  ./.prof.tmp;
    comment set -- .prof.{now,nxt,tmp}
}
dp_rmfunctions () 
{ 
    : remove the named function arguments from the collection;
    : update ./.prof.tmp;
    if_missingargs 1 $* && return;
    declare -f $(dp_functions | rm_these $*) | tee ./.prof.nxt
}
false &&
{
	return;
	# see Workflow.md

    see DOT fuse for "fuse"
    
    mv .ver/* ../version
    backup_ver 0.4.b
    find ../version -type f
    echo . . . . . . .
    ls -al .. ../{bin,lib}
    # ---------------- inspect the versioning functions	--
    #
    def dp_version backup_ver
    # ------------------------------ here is an example	--
    #
    dp_version backup_ver 2>&1

    find $(dp_version backup_ver 2>&1)
    # ----------------------------- show off the latest	--
    #
    ls -lrtd $(find $(dp_version backup_ver 2>&1))


    # dp_utilities | awk '$2 ~ /[(][)]/ { fun = $1; } /reading/ { printf "%s\t%s\n", fun, $0 }'
    
    sed -n '/false/,$p' ./.prof

    def compare_all_lib

    dp install
}        
# 
# 
#     # compare_all_lib
#     # backup_ver $(dp_version)
#     # dp_install
    # ls -al .. ../{bin,lib}
    # unset $(functions ../bin/dp{,util}lib})
    # source dp_app
    # git ls-files, git status
    # functions $(which dp_app)
    # test FUN_ASAPP
    # def dp;
    # dp abstracts | j
    # dp help
    # dp_install
    echo . . . . . . .
    def dp_{restore,rmfunctions}
