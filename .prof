source dplib
dp_utilities () 
{ 
    : functions used by dplib functions;
    declare -f $(comm -23 <(app_fun $(functions dplib) 2> /dev/null) <( dp_all| tpl))
}
eachfunction () 
{
    : list everyfunction, including same function later in file, input
    awk '$2 ~ /[(][)]/ { print $1 }' $*
}
functions ()
{
     : list functions ONCE in order of occurrence
     : due to historical precendence
     : lesson: time spent by not using PRINTFIRST, 
     eachfunction $* | awk  '!p[$1]++'
}
dp_lib () 
{ 
    : the name of the DP library;
    : date: 2022-08-19;
    : date: 2022-08-20;
    ${*:-echo} $(needir $(dp_dev))/dplib
}
dp_utillib () 
{ 
    : the name of the DP library;
    : and we have a slight mismatch because of naming conventions
    : date: 2022-08-19;
    : date: 2022-08-20;
    ${*:-echo} $(needir $(dp_dev))/dputillib
}
dp_init ()
{
    : "bring along it's utillib"
    debug ENTRY $(which dputillib)
    source $(which dputillib)
}
dp_install () 
{ 
    : move the run-time components into place;
    : date: 2022-08-20;
    local bin=$(needir $(dp_dev)/bin);
    local lib=$(needir $(dp_dev)/lib);
    : 
    ln -f $(dp_lib)          $bin
    ln -f $(dp_utillib)      $bin
    chmod 775 $bin/*
    ln -f $(dp_dev)/dot.prof $lib
}
path_reset () 
{ 
    : remove duplicates, non directory entries;
    paths | awk '!p[$0]++' | while read dir; do
        [[ -d $dir ]] && echo $dir;
    done | tr '\n' :
}
lib_tidy () 
{ 
    : backs up a library file makes it executable;
    : todo: rename lib_tidy as back_tidy, then graf_tidy as lib_tidy;
    : related: tidy_lib;
    : date: 2018-12-23;
    : date: 2021-10-10 assume tidy_lib, do NOT sort functions;
    : date: 2022-01-02;
    : date: 2022-03-04;
    debug A $*;
    : date: 2022-03-07;
    : date: 2022-04-10;
    report_notfile $1 && { 
        : debug E $*;
        return 1
    };
    local file=$1;
    backup $file;
    local slib=.slib;
    chmod 700 $slib;
    ( : SOURCE in sub-shells;
    source $file;
    declare -f $(functions $file);
    fun_starter $file ) > $slib;
    
    debug B $(wc $slib);
    [[ $(cat $slib | wc -l) -gt 0 ]] || { 
        comment $(myname) has an EMPTY replacement for $file;
        return 1
    };
    chmod 555 $slib;
    chmod 700 $file;
    cp $slib $file;
    chmod 555 $file;
    backup $file;
    debug C $(wc $slib);
    f2file $file
}
false &&
{
    return;
}
on
   backup .prof
   dp_utilities | tee $(dp_utillib)
   dp_install
   which dputillib
   ls -lisart $(find . -type f | usefulfiles)   
off

